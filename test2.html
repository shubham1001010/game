<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Babylon.js First Person Prototype with Virtual Joystick</title>
  <style>
    html, body {
      overflow: hidden;
      margin: 0;
      height: 100%;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
  
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      const canvas = document.getElementById('renderCanvas');
      const engine = new BABYLON.Engine(canvas, true);

      const createScene = function () {
        const scene = new BABYLON.Scene(engine);
        scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
        
        const camera = new BABYLON.UniversalCamera("FP_Camera", new BABYLON.Vector3(0, 2.5, -10), scene);
        camera.attachControl(canvas, true);
        camera.checkCollisions = true;
        camera.applyGravity = true;
        camera.ellipsoid = new BABYLON.Vector3(0.5, 1.75, 0.5);
        camera.ellipsoidOffset = new BABYLON.Vector3(0, 1, 0);

        const light1 = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0.3, 10, 5), scene);
        light1.diffuse = new BABYLON.Color3(0.1, 0.31, 0.5);
        light1.specular = new BABYLON.Color3(0.1, 0.1, 0.5);
        light1.intensity = 0.7;
        
        const light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0.3, 0.6, 0), scene);
        light2.diffuse = new BABYLON.Color3(1, 1, 1);
        light2.specular = new BABYLON.Color3(1, 1, 1);
        light2.intensity = 0.7;

        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 50, height: 50 }, scene);
        ground.checkCollisions = true;

        const groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
        groundMaterial.diffuseTexture = new BABYLON.Texture("https://www.babylonjs.com/assets/ground.jpg", scene);
        groundMaterial.diffuseTexture.uScale = 5; 
        groundMaterial.diffuseTexture.vScale = 5; 
        ground.material = groundMaterial;

        const box1 = BABYLON.MeshBuilder.CreateBox("box1", { size: 2 }, scene);
        box1.position = new BABYLON.Vector3(0, 1, 5);
        box1.checkCollisions = true;

        const box2 = BABYLON.MeshBuilder.CreateBox("box2", { size: 2 }, scene);
        box2.position = new BABYLON.Vector3(2, 1, 10);
        box2.checkCollisions = true;

        scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
        scene.collisionsEnabled = true;

        return scene;
      };

      const scene = createScene();

      const leftJoystick = new BABYLON.VirtualJoystick(true, {
          container: canvas,
          thumbSize: 30,
      });
      
      const rightJoystick = new BABYLON.VirtualJoystick(false, {
          container: canvas,
          thumbSize: 30,
          color: 'rgba(255, 255, 255, 0)',
      });

      scene.onBeforeRenderObservable.add(() => {
        if (scene.activeCamera) {
            var angleInput = 0;
            if (leftJoystick.pressed) {
                const speed = 0.01; // Adjust speed as needed

                // Calculate angle based on the camera's rotation
                angleInput = scene.activeCamera.rotation.y; // Get current rotation in radians

                // Calculate movement direction based on the angle input
                const radians = angleInput; // angleInput is already in radians
                const x = Math.sin(radians) * leftJoystick.deltaPosition.y * speed;
                const z = Math.cos(radians) * leftJoystick.deltaPosition.y * speed;

                let direction = new BABYLON.Vector3(x,0,z);

            scene.activeCamera.cameraDirection.addInPlace(direction);

                // Move the camera
               // scene.activeCamera.position.x += x;
            //    scene.activeCamera.position.z += z;
            }
            
            if (rightJoystick.pressed) {
                let rotationSpeed = -0.02;
                scene.activeCamera.rotation.y -= rightJoystick.deltaPosition.x * rotationSpeed;
                scene.activeCamera.rotation.x += rightJoystick.deltaPosition.y * rotationSpeed * 0.05;

                // Convert rotation to degrees for logging (optional)
                angleInput = scene.activeCamera.rotation.y;
                console.log(angleInput);

                // Clamp the camera's rotation to avoid flipping
                scene.activeCamera.rotation.x = BABYLON.Scalar.Clamp(scene.activeCamera.rotation.x, -Math.PI / 2, Math.PI / 2);
            }
        }
      });

      engine.runRenderLoop(function () {
        scene.render();
      });

      window.addEventListener('resize', function () {
        engine.resize();
      });
    });
  </script>
</body>
</html>
